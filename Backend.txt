backend: 

authentication:
    apps.py:

        from django.apps import AppConfig
class AuthenticationConfig(AppConfig):
    
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'authentication'


    models.py:

        from django.contrib.auth.models import AbstractUser, BaseUserManager
from django.db import models

class CustomUserManager(BaseUserManager):
    def create_user(self, username, email, password=None, **extra_fields):
        if not email:
            raise ValueError('El campo de correo electrónico debe estar configurado')
        email = self.normalize_email(email)
        extra_fields.setdefault('activo', True)  
        user = self.model(username=username, email=email, **extra_fields)
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, username, email, password=None, **extra_fields):
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)
        extra_fields.setdefault('activo', True) 

        if extra_fields.get('is_staff') is not True:
            raise ValueError('El superusuario debe tener is_staff=True')
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('El superusuario debe tener is_superuser=True')

        return self.create_user(username, email, password, **extra_fields)

class CustomUser(AbstractUser):
    email = models.EmailField(unique=True)
    name = models.CharField(max_length=255)
    cedula = models.CharField(max_length=20, unique=True)
    activo = models.BooleanField(default=True)  
    
    ROLE_CHOICES = [
        ('admin', 'Administrador'),
        ('coordinador', 'Coordinadora de Alimentos'),
        ('auxiliar', 'Auxiliar de Cocina'),
        ('jefe_enfermeria', 'Jefe de Enfermería'),
    ]
    role = models.CharField(max_length=20, choices=ROLE_CHOICES)

    objects = CustomUserManager()

    def __str__(self):
        return self.username


    serializers.py:

        from rest_framework import serializers
from django.contrib.auth import authenticate
from .models import CustomUser

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = CustomUser
        fields = ('id', 'username', 'password', 'email', 'name', 'cedula', 'role', 'activo')  # Incluimos 'activo'
        extra_kwargs = {'password': {'write_only': True}}

    def create(self, validated_data):
        user = CustomUser.objects.create_user(**validated_data)
        return user

    def validate_cedula(self, value):
        if CustomUser.objects.filter(cedula=value).exists():
            raise serializers.ValidationError("La cédula ya está en uso.")
        return value

class LoginSerializer(serializers.Serializer):
    username = serializers.CharField()
    password = serializers.CharField()

    def validate(self, data):
        username = data.get('username')
        password = data.get('password')

        if username and password:
            user = authenticate(username=username, password=password)
            if not user:
                raise serializers.ValidationError("Invalid credentials.")
            if not user.is_active:
                raise serializers.ValidationError("User is inactive.")
            data['user'] = user
            data['role'] = user.role
        else:
            raise serializers.ValidationError("Both username and password are required.")
        
        return data


    urls.py:

        from django.urls import path
from .views import RegisterView, LoginView, UserListView, UserDetailView
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView

urlpatterns = [
    path('register/', RegisterView.as_view(), name='register'),
    path('login/', LoginView.as_view(), name='login'),
    path('users/', UserListView.as_view(), name='user-list'),
    path('users/<int:pk>/', UserDetailView.as_view(), name='user-detail'),  
    path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),  
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]


    views.py:

        from django.contrib.auth import authenticate
from rest_framework import generics, permissions
from rest_framework.response import Response
from rest_framework_simplejwt.tokens import RefreshToken
from .models import CustomUser
from .serializers import UserSerializer, LoginSerializer
from logs.models import LogEntry

class RegisterView(generics.CreateAPIView):
    queryset = CustomUser.objects.all()
    permission_classes = [permissions.IsAdminUser]
    serializer_class = UserSerializer

    def perform_create(self, serializer):
        instance = serializer.save()
        role = self.request.data.get('role')
        if role == 'admin':
            instance.is_staff = True
            instance.is_superuser = True
            instance.save()

        LogEntry.objects.create(
            user=self.request.user,
            action='CREATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=serializer.validated_data,
        )
class LoginView(generics.GenericAPIView):
    permission_classes = (permissions.AllowAny,)
    serializer_class = LoginSerializer

    def post(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = authenticate(username=serializer.validated_data['username'], password=serializer.validated_data['password'])

        if user and user.activo:
            refresh = RefreshToken.for_user(user)
            return Response({
                'refresh': str(refresh),
                'access': str(refresh.access_token),
                'user': {
                    'role': user.role,  
                }
            })
        else:
            return Response({"error": "Invalid credentials or user inactive"}, status=400)

class UserListView(generics.ListAPIView):
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAdminUser]

    def get_queryset(self):
        return CustomUser.objects.filter(activo=True)  

    def list(self, request, *args, **kwargs):
        response = super().list(request, *args, **kwargs)
        LogEntry.objects.create(
            user=self.request.user,
            action='LIST',
            model='CustomUser',
        )
        return response

class UserDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = CustomUser.objects.all()
    serializer_class = UserSerializer
    permission_classes = [permissions.IsAdminUser]

    def perform_update(self, serializer):
        instance = serializer.save()
        LogEntry.objects.create(
            user=self.request.user,
            action='UPDATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=serializer.validated_data,
        )

    def perform_destroy(self, instance):
        LogEntry.objects.create(
            user=self.request.user,
            action='DELETE',
            model=instance.__class__.__name__,
            object_id=instance.id,
        )
        instance.delete()


logs:
    apps.py:

        from django.apps import AppConfig

class LogsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'logs'


    middleware.py

        from .models import LogEntry

class AuthenticationLoggingMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        response = self.get_response(request)
        if request.user.is_authenticated:
            if request.path == '/logout/':
                LogEntry.objects.create(
                    user=request.user,
                    action='LOGOUT',
                    model='Authentication',
                    object_id=request.user.id,
                )
            elif request.path == '/login/':
                LogEntry.objects.create(
                    user=request.user,
                    action='LOGIN',
                    model='Authentication',
                    object_id=request.user.id,
                )
        return response


    models.py:

        from django.db import models
from django.contrib.auth import get_user_model

class LogEntry(models.Model):
    ACTIONS = [
        ('CREATE', 'Create'),
        ('UPDATE', 'Update'),
        ('DELETE', 'Delete'),
        ('LOGIN', 'Login'),
        ('LOGOUT', 'Logout'),
    ]

    user = models.ForeignKey(get_user_model(), on_delete=models.SET_NULL, null=True, related_name='logs')  # Agregamos related_name
    action = models.CharField(max_length=10, choices=ACTIONS)
    model = models.CharField(max_length=50)
    object_id = models.CharField(max_length=50, null=True, blank=True)
    changes = models.JSONField(null=True, blank=True)
    timestamp = models.DateTimeField(auto_now_add=True)
    ip_address = models.GenericIPAddressField(null=True, blank=True)

    def __str__(self):
        return f'{self.action} - {self.model} - {self.object_id} by {self.user}'



backend (Carpeta de Configuraciones):
    settings.py:

        from pathlib import Path
from datetime import timedelta
import os
from dotenv import load_dotenv

load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent

SECRET_KEY = os.getenv('DJANGO_SECRET_KEY', 'ZOM50YBnVo12HpKqySoeXS9M621bNTB0JJ-mqFYpzUbnTFcMWfEh_7y2iB9ZUvVz6fg')

DEBUG = os.getenv('DJANGO_DEBUG', 'False') == 'True'

ALLOWED_HOSTS = os.getenv('DJANGO_ALLOWED_HOSTS', '').split(',')

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'corsheaders',
    'authentication',  
    'pedidos',
    'pacientes',
    'camas',
    'habitaciones',
    'servicios',
    'menus',
    'logs',
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        'rest_framework.permissions.IsAuthenticated',
    ),
}

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=60),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'AUTH_HEADER_TYPES': ('Bearer',),
    'USER_ID_FIELD': 'id',
    'USER_ID_CLAIM': 'user_id',
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),
    'TOKEN_TYPE_CLAIM': 'token_type',
}


AUTH_USER_MODEL = 'authentication.CustomUser'

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'logs.middleware.AuthenticationLoggingMiddleware',
]

CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

ROOT_URLCONF = 'backend.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'backend.wsgi.application'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': os.getenv('MYSQL_DB'),
        'USER': os.getenv('MYSQL_USER'),
        'PASSWORD': os.getenv('MYSQL_PASSWORD'),
        'HOST': os.getenv('MYSQL_HOST'),
        'PORT': os.getenv('MYSQL_PORT', '3306'),
    }
}



AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'America/Bogota'
USE_I18N = True
USE_TZ = False

STATIC_URL = 'static/'

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


    urls.py:

        from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/auth/', include('authentication.urls')),
    path('api/pacientes/', include('pacientes.urls')),
    path('api/habitaciones/', include('habitaciones.urls')),
    path('api/servicios/', include('servicios.urls')),
    path('api/menus/', include('menus.urls')),
    path('api/pedidos/', include('pedidos.urls')),
    path('api/camas/', include('camas.urls')),
]


servicios:
    apps.py:

        from django.apps import AppConfig

class ServiciosConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'servicios'


    models.py:

from django.db import models

class Servicio(models.Model):
    nombre = models.CharField(max_length=255)
    activo = models.BooleanField(default=True)

    def __str__(self):
        return self.nombre

    def save(self, *args, **kwargs):
        is_new = self.pk is None
        super().save(*args, **kwargs)

        if not is_new and not self.activo:
            from habitaciones.models import Habitacion
            from camas.models import Cama
            from pacientes.models import Paciente

            habitaciones = self.habitacion_set.all()
            habitaciones.update(activo=False)

            camas = Cama.objects.filter(habitacion__in=habitaciones)
            camas.update(activo=False)

            Paciente.objects.filter(cama__in=camas).update(activo=False)


    serializers.py:

        from rest_framework import serializers
from .models import Servicio

class ServicioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Servicio
        fields = ['id', 'nombre', 'activo']  


    urls.py:

        from django.urls import path
from .views import ServicioListCreateView, ServicioDetailView

urlpatterns = [
    path('', ServicioListCreateView.as_view(), name='servicio-list-create'),
    path('<int:pk>/', ServicioDetailView.as_view(), name='servicio-detail'),
]


    views.py:

        from rest_framework import generics
from .models import Servicio
from .serializers import ServicioSerializer
from logs.models import LogEntry  

class ServicioListCreateView(generics.ListCreateAPIView):
    serializer_class = ServicioSerializer

    def get_queryset(self):
        return Servicio.objects.all()

    def perform_create(self, serializer):
        instance = serializer.save()
        LogEntry.objects.create(
            user=self.request.user,
            action='CREATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=serializer.validated_data,
        )

class ServicioDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Servicio.objects.all()
    serializer_class = ServicioSerializer

    def perform_update(self, serializer):
        instance = serializer.save()
        LogEntry.objects.create(
            user=self.request.user,
            action='UPDATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=serializer.validated_data,
        )

    def perform_destroy(self, instance):
        LogEntry.objects.create(
            user=self.request.user,
            action='DELETE',
            model=instance.__class__.__name__,
            object_id=instance.id,
        )
        instance.delete()


habitaciones:
    apps.py:

        from django.apps import AppConfig

class HabitacionesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'habitaciones'


    models.py:

        from django.db import models
from django.db.models.signals import post_save
from django.dispatch import receiver
from servicios.models import Servicio  
from django.core.exceptions import ValidationError

class Habitacion(models.Model):
    nombre = models.CharField(max_length=255, unique=True)
    servicio = models.ForeignKey(Servicio, on_delete=models.CASCADE)
    activo = models.BooleanField(default=True)

    def __str__(self):
        return self.nombre

    def save(self, *args, **kwargs):
        if self.activo and not self.servicio.activo:
            raise ValidationError('No se puede activar una habitación si el servicio no está activo.')
        super().save(*args, **kwargs)

@receiver(post_save, sender=Habitacion)
def desactivar_camas_y_pacientes(sender, instance, **kwargs):
    if not instance.activo:
        from camas.models import Cama  
        from pacientes.models import Paciente  

        instance.camas.update(activo=False)
        Paciente.objects.filter(cama__habitacion=instance).update(activo=False)


    serializers.py:

        from rest_framework import serializers
from .models import Habitacion
from servicios.models import Servicio
from camas.serializers import CamaSerializer

class HabitacionSerializer(serializers.ModelSerializer):
    servicio_id = serializers.PrimaryKeyRelatedField(queryset=Servicio.objects.all(), source='servicio', write_only=True)
    servicio = serializers.ReadOnlyField(source='servicio.nombre')
    camas = CamaSerializer(many=True, read_only=True)

    class Meta:
        model = Habitacion
        fields = ['id', 'nombre', 'servicio_id', 'servicio', 'activo', 'camas']

    def create(self, validated_data):
        habitacion = Habitacion.objects.create(**validated_data)
        return habitacion

    def update(self, instance, validated_data):
        instance.nombre = validated_data.get('nombre', instance.nombre)
        instance.servicio = validated_data.get('servicio', instance.servicio)
        instance.activo = validated_data.get('activo', instance.activo)

        if instance.activo and not instance.servicio.activo:
            raise serializers.ValidationError("No se puede activar la habitación porque el servicio está inactivo.")

        instance.save()

        if not instance.activo:
            instance.camas.update(activo=False)

        return instance


    urls.py:

        from django.urls import path
from .views import HabitacionListCreateView, HabitacionDetailView

urlpatterns = [
    path('', HabitacionListCreateView.as_view(), name='habitacion-list-create'),
    path('<int:pk>/', HabitacionDetailView.as_view(), name='habitacion-detail'),
]


    views.py:

        from rest_framework import generics
from .models import Habitacion
from .serializers import HabitacionSerializer
from logs.models import LogEntry  

class HabitacionListCreateView(generics.ListCreateAPIView):
    serializer_class = HabitacionSerializer

    def get_queryset(self):
        return Habitacion.objects.all()

    def perform_create(self, serializer):
        instance = serializer.save()
        changes = {
            'nombre': instance.nombre,
            'servicio_id': instance.servicio.id,
            'activo': instance.activo,
        }
        LogEntry.objects.create(
            user=self.request.user,
            action='CREATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=changes,  
        )

class HabitacionDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Habitacion.objects.all()
    serializer_class = HabitacionSerializer

    def perform_update(self, serializer):
        instance = serializer.save()
        changes = {
            'nombre': instance.nombre,
            'servicio_id': instance.servicio.id,
            'activo': instance.activo,
        }
        LogEntry.objects.create(
            user=self.request.user,
            action='UPDATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=changes,  
        )

    def perform_destroy(self, instance):
        LogEntry.objects.create(
            user=self.request.user,
            action='DELETE',
            model=instance.__class__.__name__,
            object_id=instance.id,
        )
        instance.delete()


camas:
    apps.py:

        from django.apps import AppConfig

class CamasConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'camas'


    models.py:

        from django.db import models
from django.core.exceptions import ValidationError
from django.db.models.signals import post_save  
from django.dispatch import receiver  
from habitaciones.models import Habitacion

class Cama(models.Model):
    nombre = models.CharField(max_length=50)
    habitacion = models.ForeignKey(Habitacion, related_name='camas', on_delete=models.CASCADE)
    activo = models.BooleanField(default=True)

    class Meta:
        unique_together = ('nombre', 'habitacion')

    def __str__(self):
        return f'{self.nombre} - {self.habitacion.nombre}'

@receiver(post_save, sender=Cama)
def desactivar_paciente(sender, instance, **kwargs):
    if not instance.activo:  
        from pacientes.models import Paciente  
        Paciente.objects.filter(cama=instance).update(activo=False)

@receiver(post_save, sender=Cama)
def validar_activacion_cama(sender, instance, **kwargs):
    if instance.activo and not instance.habitacion.activo:
        raise ValidationError('No se puede activar una cama si la habitación no está activa.')


    serializers.py:

        from rest_framework import serializers
from .models import Cama

class CamaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Cama
        fields = ['id', 'nombre', 'habitacion', 'activo']


    urls.py:

        from django.urls import path
from .views import CamaListCreateView, CamaDetailView

urlpatterns = [
    path('', CamaListCreateView.as_view(), name='cama-list-create'),
    path('<int:pk>/', CamaDetailView.as_view(), name='cama-detail'),
]


    views.py:

        from rest_framework import generics
from .models import Cama
from .serializers import CamaSerializer
from logs.models import LogEntry  

class CamaListCreateView(generics.ListCreateAPIView):
    queryset = Cama.objects.all()
    serializer_class = CamaSerializer

    def perform_create(self, serializer):
        instance = serializer.save()
        changes = {
            'nombre': instance.nombre,
            'habitacion_id': instance.habitacion.id,
            'activo': instance.activo,
        }
        LogEntry.objects.create(
            user=self.request.user,
            action='CREATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=changes,  
        )

class CamaDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Cama.objects.all()
    serializer_class = CamaSerializer

    def perform_update(self, serializer):
        instance = serializer.save()
        changes = {
            'nombre': instance.nombre,
            'habitacion_id': instance.habitacion.id,
            'activo': instance.activo,
        }
        LogEntry.objects.create(
            user=self.request.user,
            action='UPDATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=changes,  
        )

    def perform_destroy(self, instance):
        LogEntry.objects.create(
            user=self.request.user,
            action='DELETE',
            model=instance.__class__.__name__,
            object_id=instance.id,
        )
        instance.delete()


pacientes:
    apps.py:

        from django.apps import AppConfig

class PacientesConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'pacientes'


    models.py:

        from django.db import models
from django.core.exceptions import ValidationError
from camas.models import Cama

class Paciente(models.Model):
    id = models.AutoField(primary_key=True)  
    cedula = models.CharField(max_length=20)  
    name = models.CharField(max_length=100)
    cama = models.ForeignKey(Cama, on_delete=models.CASCADE)
    recommended_diet = models.CharField(max_length=255)
    activo = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)  

    def save(self, *args, **kwargs):
        if self.activo:
            if not self.cama.activo:
                raise ValidationError('No se puede activar un paciente porque la cama no está activa.')
            if not self.cama.habitacion.activo:
                raise ValidationError('No se puede activar un paciente porque la habitación no está activa.')
            if not self.cama.habitacion.servicio.activo:
                raise ValidationError('No se puede activar un paciente porque el servicio no está activo.')
        else:
            self.cama.activo = False
            self.cama.save()

        super(Paciente, self).save(*args, **kwargs)

    def __str__(self):
        return self.name


    serializers.py:

        from rest_framework import serializers
from rest_framework.exceptions import ValidationError as DRFValidationError
from django.core.exceptions import ValidationError
from .models import Paciente
from camas.models import Cama
from habitaciones.models import Habitacion
from servicios.models import Servicio

class ServicioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Servicio
        fields = ['id', 'nombre']

class HabitacionSerializer(serializers.ModelSerializer):
    servicio = ServicioSerializer(read_only=True)

    class Meta:
        model = Habitacion
        fields = ['id', 'nombre', 'servicio']

class CamaSerializer(serializers.ModelSerializer):
    habitacion = HabitacionSerializer(read_only=True)

    class Meta:
        model = Cama
        fields = ['id', 'nombre', 'habitacion']

class PacienteSerializer(serializers.ModelSerializer):
    cama_id = serializers.PrimaryKeyRelatedField(queryset=Cama.objects.all(), source='cama', write_only=True)
    cama = CamaSerializer(read_only=True)

    class Meta:
        model = Paciente
        fields = ['id', 'cedula', 'name', 'cama_id', 'cama', 'recommended_diet', 'activo', 'created_at']  

    def create(self, validated_data):
        return Paciente.objects.create(**validated_data)

    def update(self, instance, validated_data):
        instance.name = validated_data.get('name', instance.name)
        instance.cama = validated_data.get('cama', instance.cama)
        instance.recommended_diet = validated_data.get('recommended_diet', instance.recommended_diet)
        instance.activo = validated_data.get('activo', instance.activo)
        
        try:
            instance.save()
        except ValidationError as e:
            raise DRFValidationError({"detail": e.messages})  

        return instance


    urls.py:

        from django.urls import path
from .views import PacienteListCreateView, PacienteDetailView

urlpatterns = [
    path('', PacienteListCreateView.as_view(), name='paciente-list-create'),
    path('<int:pk>/', PacienteDetailView.as_view(), name='paciente-detail'),  
]


    views.py:

        from rest_framework import generics
from .models import Paciente
from .serializers import PacienteSerializer
from logs.models import LogEntry  

class PacienteListCreateView(generics.ListCreateAPIView):
    serializer_class = PacienteSerializer

    def get_queryset(self):
        return Paciente.objects.filter(activo=True)  

    def create(self, request, *args, **kwargs):
        response = super().create(request, *args, **kwargs)
        LogEntry.objects.create(
            user=self.request.user,
            action='CREATE',
            model='Paciente',
            object_id=response.data['id'],
            changes=request.data,
        )
        return response

class PacienteDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Paciente.objects.all()
    serializer_class = PacienteSerializer

    def perform_update(self, serializer):
        instance = serializer.save()
        LogEntry.objects.create(
            user=self.request.user,
            action='UPDATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=serializer.validated_data,
        )

    def perform_destroy(self, instance):
        LogEntry.objects.create(
            user=self.request.user,
            action='DELETE',
            model=instance.__class__.__name__,
            object_id=instance.id,
        )
        instance.delete()


menus:
    apps.py:

        from django.apps import AppConfig

class MenusConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'menus'


    models.py:

        from django.db import models

class Menu(models.Model):
    nombre = models.CharField(max_length=255)

    def __str__(self):
        return self.nombre

class MenuSection(models.Model):
    menu = models.ForeignKey(Menu, on_delete=models.CASCADE, related_name='sections')
    titulo = models.CharField(max_length=255)

    def __str__(self):
        return self.titulo

class MenuOption(models.Model):
    section = models.ForeignKey(MenuSection, on_delete=models.CASCADE, related_name='options')
    texto = models.CharField(max_length=255)
    tipo = models.CharField(max_length=50)

    def __str__(self):
        return self.texto


    serializers.py:

        from rest_framework import serializers
from .models import Menu, MenuSection, MenuOption

class MenuOptionSerializer(serializers.ModelSerializer):
    class Meta:
        model = MenuOption 
        fields = ['id', 'texto', 'tipo'] 

class MenuSectionSerializer(serializers.ModelSerializer):
    adicionales = serializers.SerializerMethodField()
    platos_principales = serializers.SerializerMethodField()
    acompanantes = serializers.SerializerMethodField()
    bebidas = serializers.SerializerMethodField()

    class Meta:
        model = MenuSection  
        fields = ['id', 'titulo', 'adicionales', 'platos_principales', 'acompanantes', 'bebidas']  # Campos a incluir en la serialización

    def get_adicionales(self, obj):
        return MenuOptionSerializer(obj.options.filter(tipo='adicionales'), many=True).data

    def get_platos_principales(self, obj):
        return MenuOptionSerializer(obj.options.filter(tipo='platos_principales'), many=True).data

    def get_acompanantes(self, obj):
        return MenuOptionSerializer(obj.options.filter(tipo='acompanantes'), many=True).data

    def get_bebidas(self, obj):
        return MenuOptionSerializer(obj.options.filter(tipo='bebidas'), many=True).data

class MenuSerializer(serializers.ModelSerializer):
    sections = MenuSectionSerializer(many=True, required=False)

    class Meta:
        model = Menu  
        fields = ['id', 'nombre', 'sections']  

    def create(self, validated_data):
        sections_data = self.context['request'].data.get('sections', [])
        menu = Menu.objects.create(nombre=validated_data.get('nombre'))
        for section_data in sections_data:
            adicionales_data = section_data.pop('adicionales', [])
            platos_principales_data = section_data.pop('platos_principales', [])
            acompanantes_data = section_data.pop('acompanantes', [])
            bebidas_data = section_data.pop('bebidas', [])
            section = MenuSection.objects.create(menu=menu, titulo=section_data['titulo'])
            for adicional_data in adicionales_data:
                MenuOption.objects.create(section=section, **adicional_data)
            for plato_principal_data in platos_principales_data:
                MenuOption.objects.create(section=section, **plato_principal_data)
            for acompanante_data in acompanantes_data:
                MenuOption.objects.create(section=section, **acompanante_data)
            for bebida_data in bebidas_data:
                MenuOption.objects.create(section=section, **bebida_data)
        return menu

    def update(self, instance, validated_data):
        sections_data = self.context['request'].data.get('sections', [])
        instance.nombre = validated_data.get('nombre', instance.nombre)
        instance.save()

        existing_section_ids = {section.id for section in instance.sections.all()}
        request_section_ids = {section_data.get('id') for section_data in sections_data if 'id' in section_data}
        sections_to_delete = existing_section_ids - request_section_ids
        if sections_to_delete:
            MenuSection.objects.filter(id__in=sections_to_delete).delete()

        for section_data in sections_data:
            adicionales_data = section_data.pop('adicionales', [])
            platos_principales_data = section_data.pop('platos_principales', [])
            acompanantes_data = section_data.pop('acompanantes', [])
            bebidas_data = section_data.pop('bebidas', [])
            section_id = section_data.get('id')

            if section_id and MenuSection.objects.filter(id=section_id, menu=instance).exists():
                section = MenuSection.objects.get(id=section_id, menu=instance)
                section.titulo = section_data.get('titulo', section.titulo)
                section.save()

                section.options.all().delete()
            else:
                section = MenuSection.objects.create(menu=instance, **section_data)

            for adicional_data in adicionales_data:
                MenuOption.objects.create(section=section, **adicional_data)
            for plato_principal_data in platos_principales_data:
                MenuOption.objects.create(section=section, **plato_principal_data)
            for acompanante_data in acompanantes_data:
                MenuOption.objects.create(section=section, **acompanante_data)
            for bebida_data in bebidas_data:
                MenuOption.objects.create(section=section, **bebida_data)

        return instance


    urls.py:

        from django.urls import path
from .views import MenuListCreateView, MenuDetailView

urlpatterns = [
    path('', MenuListCreateView.as_view(), name='menu-list-create'),
    path('<int:pk>/', MenuDetailView.as_view(), name='menu-detail'),
]


    views.py:

        from rest_framework import generics
from .models import Menu
from .serializers import MenuSerializer
from logs.models import LogEntry  

class MenuListCreateView(generics.ListCreateAPIView):
    queryset = Menu.objects.all()
    serializer_class = MenuSerializer

    def perform_create(self, serializer):
        instance = serializer.save()
        LogEntry.objects.create(
            user=self.request.user,
            action='CREATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=serializer.validated_data,
        )

class MenuDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Menu.objects.all()
    serializer_class = MenuSerializer

    def perform_update(self, serializer):
        instance = serializer.save()
        LogEntry.objects.create(
            user=self.request.user,
            action='UPDATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=serializer.validated_data,
        )

    def perform_destroy(self, instance):
        LogEntry.objects.create(
            user=self.request.user,
            action='DELETE',
            model=instance.__class__.__name__,
            object_id=instance.id,
        )
        instance.delete()


pedidos:
    apps.py:

        from django.apps import AppConfig

class PedidosConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'pedidos'


    models.py:

        from django.db import models
from pacientes.models import Paciente
from menus.models import Menu, MenuOption

class Pedido(models.Model):
    STATUS_CHOICES = [
        ('pendiente', 'Pendiente'),
        ('en_proceso', 'En Proceso'),
        ('completado', 'Completado'),
    ]

    paciente = models.ForeignKey(Paciente, on_delete=models.CASCADE)
    menu = models.ForeignKey(Menu, on_delete=models.CASCADE)
    opciones = models.ManyToManyField(MenuOption, through='PedidoMenuOption', blank=True, related_name='pedidos')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pendiente')
    fecha_pedido = models.DateTimeField(auto_now_add=True)
    adicionales = models.JSONField(default=dict, blank=True)
    sectionStatus = models.JSONField(default=dict, blank=True)  

    def __str__(self):
        return f"Pedido {self.id} - {self.paciente.name} - {self.status}"

class PedidoMenuOption(models.Model):
    pedido = models.ForeignKey(Pedido, on_delete=models.CASCADE)
    menu_option = models.ForeignKey(MenuOption, on_delete=models.CASCADE)
    selected = models.BooleanField(default=False)
    


    serializers.py:

        from rest_framework import serializers
from pedidos.models import Pedido, PedidoMenuOption
from pacientes.models import Paciente
from pacientes.serializers import PacienteSerializer
from menus.models import Menu, MenuOption
from menus.serializers import MenuSerializer, MenuOptionSerializer

class PedidoMenuOptionSerializer(serializers.ModelSerializer):
    menu_option = MenuOptionSerializer()
    class Meta:
        model = PedidoMenuOption
        fields = ['menu_option', 'selected']

class PedidoSerializer(serializers.ModelSerializer):
    paciente = PacienteSerializer(read_only=True)
    menu = MenuSerializer(read_only=True)
    opciones = PedidoMenuOptionSerializer(source='pedidomenuoption_set', many=True, read_only=True)

    class Meta:
        model = Pedido
        fields = ['id', 'paciente', 'menu', 'opciones', 'status', 'fecha_pedido', 'adicionales', 'sectionStatus']

    def create(self, validated_data):
        opciones_data = self.initial_data.get('opciones', [])
        adicionales_data = validated_data.pop('adicionales')
        section_status_data = validated_data.pop('sectionStatus', {})
        paciente_id = self.initial_data.get('paciente')
        menu_id = self.initial_data.get('menu')

        paciente = Paciente.objects.get(id=paciente_id)
        menu = Menu.objects.get(id=menu_id)

        pedido = Pedido.objects.create(paciente=paciente, menu=menu, sectionStatus=section_status_data, **validated_data)

        for opcion_data in opciones_data:
            opcion_id = opcion_data.get('id')
            if opcion_id is not None:
                selected = opcion_data.get('selected', False)
                menu_option = MenuOption.objects.get(id=opcion_id)
                PedidoMenuOption.objects.create(pedido=pedido, menu_option=menu_option, selected=selected)

        pedido.adicionales = adicionales_data
        pedido.save()

        return pedido

    def update(self, instance, validated_data):
        opciones_data = self.initial_data.get('opciones', [])
        adicionales_data = validated_data.pop('adicionales', instance.adicionales)
        section_status_data = validated_data.pop('sectionStatus', instance.sectionStatus)

        print(f"Actualizando pedido ID: {instance.id}")

        instance.paciente = validated_data.get('paciente', instance.paciente)
        instance.menu = validated_data.get('menu', instance.menu)
        instance.status = validated_data.get('status', instance.status)
        instance.adicionales = adicionales_data
        instance.sectionStatus = section_status_data
        instance.save()

        if opciones_data:
            for opcion_data in opciones_data:
                opcion_id = opcion_data.get('id')
                if opcion_id is not None:
                    try:
                        menu_option = MenuOption.objects.get(id=opcion_id)
                        selected = opcion_data['selected']
                        PedidoMenuOption.objects.update_or_create(
                            pedido=instance,
                            menu_option=menu_option,
                            defaults={'selected': selected}
                        )
                    except MenuOption.DoesNotExist:
                        print(f"MenuOption con ID {opcion_id} no existe. Saltando esta opción.")
                        continue

        print(f"Pedido actualizado con status: {instance.status}")
        return instance


    urls.py:

        from django.urls import path
from .views import PedidoListCreateView, PedidoDetailView, PedidoStatusUpdateView, PedidoCompletadosView, PedidoPrintView

urlpatterns = [
    path('', PedidoListCreateView.as_view(), name='pedido-list-create'),
    path('<int:pk>/', PedidoDetailView.as_view(), name='pedido-detail'),
    path('<int:pk>/status/', PedidoStatusUpdateView.as_view(), name='pedido-status-update'),
    path('completados/', PedidoCompletadosView.as_view(), name='pedido-completados'),
    path('<int:pk>/print/', PedidoPrintView.as_view(), name='pedido-print'),
]

    views.py:

        from rest_framework import generics, views
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Pedido
from .serializers import PedidoSerializer
from logs.models import LogEntry 
import usb.core
import usb.util

class PedidoListCreateView(generics.ListCreateAPIView):
    queryset = Pedido.objects.all()
    serializer_class = PedidoSerializer

    def perform_create(self, serializer):
        instance = serializer.save()
        LogEntry.objects.create(
            user=self.request.user,
            action='CREATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=serializer.validated_data,
        )

    @action(detail=False, methods=['get'])
    def pendientes(self, request):
        pedidos_pendientes = Pedido.objects.filter(status='pendiente')
        serializer = self.get_serializer(pedidos_pendientes, many=True)
        LogEntry.objects.create(
            user=self.request.user,
            action='LIST',
            model='Pedido',
        )
        return Response(serializer.data)

class PedidoCompletadosView(views.APIView):
    def get(self, request):
        paciente_id = request.query_params.get('paciente', None)
        pedidos_completados = Pedido.objects.filter(status='completado')
        
        if paciente_id:
            pedidos_completados = pedidos_completados.filter(paciente__id=paciente_id)

        LogEntry.objects.create(
            user=self.request.user,
            action='LIST',
            model='Pedido',
        )

        serializer = PedidoSerializer(pedidos_completados, many=True)
        return Response(serializer.data)

class PedidoDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Pedido.objects.all()
    serializer_class = PedidoSerializer

    def perform_update(self, serializer):
        instance = serializer.save()
        LogEntry.objects.create(
            user=self.request.user,
            action='UPDATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=serializer.validated_data,
        )

    def perform_destroy(self, instance):
        LogEntry.objects.create(
            user=self.request.user,
            action='DELETE',
            model=instance.__class__.__name__,
            object_id=instance.id,
        )
        instance.delete()

class PedidoStatusUpdateView(generics.UpdateAPIView):
    queryset = Pedido.objects.all()
    serializer_class = PedidoSerializer

    def partial_update(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        LogEntry.objects.create(
            user=self.request.user,
            action='UPDATE',
            model=instance.__class__.__name__,
            object_id=instance.id,
            changes=request.data,
        )
        return Response(serializer.data)

class PedidoPrintView(views.APIView):
    def post(self, request, pk):
        try:
            pedido = Pedido.objects.get(pk=pk)
            self.print_pedido(pedido)
            return Response({"status": "success", "message": "Pedido impreso con éxito."})
        except Pedido.DoesNotExist:
            return Response({"status": "error", "message": "Pedido no encontrado."}, status=404)

    def print_pedido(self, pedido):
        dev = usb.core.find(idVendor=0x1FC9, idProduct=0x2016)

        if dev is None:
            raise ValueError('Dispositivo no encontrado')

        dev.set_configuration()

        cfg = dev.get_active_configuration()
        interface_number = cfg[(0,0)].bInterfaceNumber
        intf = usb.util.find_descriptor(cfg, bInterfaceNumber=interface_number)
        ep = usb.util.find_descriptor(
            intf,
            custom_match=lambda e: usb.util.endpoint_direction(e.bEndpointAddress) == usb.util.ENDPOINT_OUT
        )

        print_data = (
            "===============================\n"
            f"Paciente: {pedido.paciente.name}\n"
            f"Servicio: {pedido.paciente.cama.habitacion.servicio.nombre}\n"
            f"Habitación: {pedido.paciente.cama.habitacion.nombre}\n"
            f"Cama: {pedido.paciente.cama.nombre}\n"
            "===============================\n\n\n"
        )

        try:
            ep.write(b'\x1b\x40' + print_data.encode('utf-8'))
            ep.write(b'\n\n\n\n\n')
            ep.write(b'\x1d\x56\x00')
        finally:
            usb.util.release_interface(dev, interface_number)
            usb.util.dispose_resources(dev)
            print("Información del paciente impresa y dispositivo liberado con éxito.")


.env: 
    DJANGO_SECRET_KEY=ZOM50YBnVo12HpKqySoeXS9M621bNTB0JJ-mqFYpzUbnTFcMWfEh_7y2iB9ZUvVz6fg

DJANGO_DEBUG=True

DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1,172.168.11.176  

MYSQL_DB=menusjdd
MYSQL_USER=root
MYSQL_PASSWORD=
MYSQL_HOST=localhost
MYSQL_PORT=3306



