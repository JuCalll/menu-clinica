# Importamos el modelo AbstractUser y BaseUserManager desde django.contrib.auth.models
from django.contrib.auth.models import AbstractUser, BaseUserManager
# Importamos el módulo models de Django
from django.db import models

# Definimos un gestor personalizado para el modelo de usuario
class CustomUserManager(BaseUserManager):

    # Método para crear un usuario normal
    def create_user(self, username, email, password=None, **extra_fields):
        # Verificamos si el correo electrónico está presente
        if not email:
            raise ValueError('El campo de correo electrónico debe estar configurado')
        # Normalizamos el correo electrónico (conversión a minúsculas y manejo de dominio)
        email = self.normalize_email(email)
        # Creamos una instancia del modelo de usuario con los campos proporcionados
        user = self.model(username=username, email=email, **extra_fields)
        # Establecemos la contraseña para el usuario
        user.set_password(password)
        # Guardamos el usuario en la base de datos
        user.save(using=self._db)
        # Retornamos el usuario creado
        return user

    # Método para crear un superusuario
    def create_superuser(self, username, email, password=None, **extra_fields):
        # Establecemos valores por defecto para los campos is_staff e is_superuser
        extra_fields.setdefault('is_staff', True)
        extra_fields.setdefault('is_superuser', True)

        # Verificamos que is_staff sea True para un superusuario
        if extra_fields.get('is_staff') is not True:
            raise ValueError('El superusuario debe tener is_staff=True')
        # Verificamos que is_superuser sea True para un superusuario
        if extra_fields.get('is_superuser') is not True:
            raise ValueError('El superusuario debe tener is_superuser=True')

        # Creamos y retornamos el superusuario utilizando el método create_user
        return self.create_user(username, email, password, **extra_fields)

# Definimos un modelo de usuario personalizado que hereda de AbstractUser
class CustomUser(AbstractUser):
    # Reemplazamos el campo de correo electrónico por uno que debe ser único
    email = models.EmailField(unique=True)

    # Asociamos el gestor de usuarios personalizado a este modelo
    objects = CustomUserManager()

    # Método para representar el usuario como una cadena de texto
    def __str__(self):
        # Retornamos el nombre de usuario
        return self.username
# Importamos el módulo serializers de Django REST framework
from rest_framework import serializers
# Importamos el modelo CustomUser desde el archivo models
from .models import CustomUser

# Definimos un serializer para el modelo CustomUser
class UserSerializer(serializers.ModelSerializer):
    # Meta clase que define el modelo y los campos a serializar
    class Meta:
        model = CustomUser  # Especificamos el modelo CustomUser
        fields = ('id', 'username', 'password', 'email')  # Campos a incluir en la serialización
        # Indicamos que el campo password solo debe ser utilizado para escritura (no se devolverá en respuestas)
        extra_kwargs = {'password': {'write_only': True}}

    # Método para crear un nuevo usuario con los datos validados
    def create(self, validated_data):
        # Utilizamos el gestor personalizado para crear un usuario con los datos validados
        user = CustomUser.objects.create_user(**validated_data)
        # Retornamos el usuario creado
        return user

# Definimos un serializer para manejar el login del usuario
class LoginSerializer(serializers.Serializer):
    # Campos que se necesitan para autenticar a un usuario
    username = serializers.CharField()  # Campo para el nombre de usuario
    password = serializers.CharField()  # Campo para la contraseña
# Importamos el módulo path desde django.urls para definir rutas
from django.urls import path
# Importamos las vistas RegisterView y LoginView desde el archivo views
from .views import RegisterView, LoginView
# Importamos las vistas TokenObtainPairView y TokenRefreshView desde rest_framework_simplejwt.views
# Estas vistas se utilizan para manejar la obtención y la actualización de tokens JWT
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView

# Definimos las rutas de la aplicación 'authentication'
urlpatterns = [
    # Ruta para registrar un nuevo usuario, asociada a la vista RegisterView
    path('register/', RegisterView.as_view(), name='register'),
    # Ruta para iniciar sesión, asociada a la vista LoginView
    path('login/', LoginView.as_view(), name='login'),
    # Ruta para obtener un nuevo par de tokens (access y refresh), asociada a la vista TokenObtainPairView
    path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    # Ruta para refrescar un token de acceso usando el token de refresh, asociada a la vista TokenRefreshView
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
]
# Importamos la función authenticate de django.contrib.auth para autenticar usuarios
from django.contrib.auth import authenticate
# Importamos los módulos generics y permissions de Django REST framework
from rest_framework import generics, permissions
# Importamos la clase Response para manejar las respuestas HTTP en las vistas
from rest_framework.response import Response
# Importamos la clase RefreshToken de rest_framework_simplejwt.tokens para manejar los tokens JWT
from rest_framework_simplejwt.tokens import RefreshToken
# Importamos el modelo CustomUser desde el archivo models
from .models import CustomUser
# Importamos los serializers UserSerializer y LoginSerializer desde el archivo serializers
from .serializers import UserSerializer, LoginSerializer

# Definimos una vista para registrar nuevos usuarios
class RegisterView(generics.CreateAPIView):
    # Especificamos el queryset para recuperar todos los usuarios (aunque en este caso solo se utiliza para crear)
    queryset = CustomUser.objects.all()
    # Permitimos el acceso a cualquier usuario, incluso si no está autenticado
    permission_classes = (permissions.AllowAny,)
    # Especificamos el serializer que será utilizado para validar y deserializar los datos de la solicitud
    serializer_class = UserSerializer

# Definimos una vista para manejar el login de usuarios
class LoginView(generics.GenericAPIView):
    # Permitimos el acceso a cualquier usuario, incluso si no está autenticado
    permission_classes = (permissions.AllowAny,)
    # Especificamos el serializer que será utilizado para validar y deserializar los datos de la solicitud
    serializer_class = LoginSerializer

    # Método POST para manejar la solicitud de login
    def post(self, request, *args, **kwargs):
        # Validamos los datos recibidos utilizando el serializer
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        # Autenticamos al usuario utilizando el nombre de usuario y la contraseña proporcionados
        user = authenticate(username=serializer.validated_data['username'], password=serializer.validated_data['password'])
        # Si la autenticación es exitosa, generamos y devolvemos los tokens JWT
        if user:
            # Generamos un nuevo refresh token para el usuario autenticado
            refresh = RefreshToken.for_user(user)
            # Devolvemos el refresh token y el access token en la respuesta
            return Response({
                'refresh': str(refresh),
                'access': str(refresh.access_token),
            })
        # Si la autenticación falla, devolvemos un error
        return Response({"error": "Credenciales inválidas"}, status=400)
# Importamos el módulo os para interactuar con las variables de entorno del sistema operativo
import os

# Importamos la función get_asgi_application de django.core.asgi para configurar la aplicación ASGI
from django.core.asgi import get_asgi_application

# Establecemos la variable de entorno 'DJANGO_SETTINGS_MODULE' con el valor 'backend.settings'
# Esto indica a Django qué archivo de configuración debe usar
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

# Llamamos a get_asgi_application para obtener la aplicación ASGI que Django utilizará
application = get_asgi_application()
# Importamos Path de pathlib para manejar rutas de archivos
from pathlib import Path
# Importamos timedelta de datetime para manejar intervalos de tiempo
from datetime import timedelta
# Importamos os para interactuar con variables de entorno y el sistema operativo
import os
# Importamos load_dotenv de dotenv para cargar variables de entorno desde un archivo .env
from dotenv import load_dotenv

# Cargar variables de entorno desde el archivo .env
load_dotenv()

# Definimos la ruta base del proyecto, es decir, la carpeta principal que contiene todos los archivos del proyecto
BASE_DIR = Path(__file__).resolve().parent.parent

# Obtener las variables de entorno

# Se obtiene la clave secreta de Django desde una variable de entorno, si no se encuentra, se usa un valor por defecto (esto no es seguro para producción)
SECRET_KEY = os.getenv('DJANGO_SECRET_KEY', 'ZOM50YBnVo12HpKqySoeXS9M621bNTB0JJ-mqFYpzUbnTFcMWfEh_7y2iB9ZUvVz6fg')

# Se establece si el modo debug está activado o no, basado en una variable de entorno
DEBUG = os.getenv('DJANGO_DEBUG', 'False') == 'True'

# Lista de hosts permitidos, se separa en una lista desde una cadena en la variable de entorno
ALLOWED_HOSTS = os.getenv('DJANGO_ALLOWED_HOSTS', '').split(',')

# Definimos las aplicaciones instaladas en el proyecto
INSTALLED_APPS = [
    'django.contrib.admin',  # Admin de Django
    'django.contrib.auth',  # Autenticación de Django
    'django.contrib.contenttypes',  # Tipos de contenido de Django
    'django.contrib.sessions',  # Manejo de sesiones en Django
    'django.contrib.messages',  # Manejo de mensajes en Django
    'django.contrib.staticfiles',  # Archivos estáticos en Django
    'rest_framework',  # Django REST framework
    'corsheaders',  # Manejo de CORS (Cross-Origin Resource Sharing)
    'authentication',  # Aplicación de autenticación personalizada
    'pedidos',  # Aplicación de gestión de pedidos
    'pacientes',  # Aplicación de gestión de pacientes
    'habitaciones',  # Aplicación de gestión de habitaciones
    'servicios',  # Aplicación de gestión de servicios
    'menus',  # Aplicación de gestión de menús
]

# Configuraciones para Django REST framework
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        # Autenticación basada en tokens JWT
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (
        # Solo usuarios autenticados pueden acceder a las vistas
        'rest_framework.permissions.IsAuthenticated',
    ),
}

# Configuraciones para JWT (JSON Web Tokens)
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(hours=1),  # Tiempo de vida del token de acceso
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),  # Tiempo de vida del token de refresco
    'BLACKLIST_AFTER_ROTATION': True,  # Poner en lista negra el token anterior después de refrescar
    'UPDATE_LAST_LOGIN': False,  # No actualizar el último inicio de sesión automáticamente
    'ALGORITHM': 'HS256',  # Algoritmo de cifrado para los tokens
    'SIGNING_KEY': SECRET_KEY,  # Clave secreta para firmar los tokens
    'VERIFYING_KEY': None,  # Clave para verificar los tokens (no utilizada aquí)
    'AUDIENCE': None,  # Audiencia (no utilizada aquí)
    'ISSUER': None,  # Emisor (no utilizado aquí)
    'AUTH_HEADER_TYPES': ('Bearer',),  # Tipo de cabecera para el token
    'USER_ID_FIELD': 'id',  # Campo que identifica al usuario en el token
    'USER_ID_CLAIM': 'user_id',  # Reclamación que identifica al usuario en el token
    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),  # Clases de tokens utilizados
    'TOKEN_TYPE_CLAIM': 'token_type',  # Tipo de token en la reclamación
    'JTI_CLAIM': 'jti',  # Identificador único de token
    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',  # Reclamación de expiración del token de refresco deslizante
    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=10),  # Tiempo de vida del token deslizante
    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),  # Tiempo de vida del refresco deslizante
}

# Especificamos que el modelo de usuario personalizado se utilizará en lugar del modelo de usuario predeterminado de Django
AUTH_USER_MODEL = 'authentication.CustomUser'

# Definimos el middleware utilizado en el proyecto
MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',  # Middleware para manejar CORS
    'django.middleware.common.CommonMiddleware',  # Middleware común de Django
    'django.middleware.security.SecurityMiddleware',  # Middleware de seguridad de Django
    'django.contrib.sessions.middleware.SessionMiddleware',  # Middleware de manejo de sesiones
    'django.middleware.csrf.CsrfViewMiddleware',  # Middleware de protección contra CSRF
    'django.contrib.auth.middleware.AuthenticationMiddleware',  # Middleware de autenticación
    'django.contrib.messages.middleware.MessageMiddleware',  # Middleware de manejo de mensajes
    'django.middleware.clickjacking.XFrameOptionsMiddleware',  # Protección contra clickjacking
]

# Configuración para permitir todas las fuentes de CORS y permitir credenciales
CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

# Especificamos el archivo de configuración de URLs raíz para el proyecto
ROOT_URLCONF = 'backend.urls'

# Configuraciones de plantillas de Django
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',  # Backend de plantillas
        'DIRS': [],  # Directorios adicionales para buscar plantillas
        'APP_DIRS': True,  # Buscar plantillas en los directorios de las aplicaciones
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',  # Contexto de depuración
                'django.template.context_processors.request',  # Contexto de la solicitud
                'django.contrib.auth.context_processors.auth',  # Contexto de autenticación
                'django.contrib.messages.context_processors.messages',  # Contexto de mensajes
            ],
        },
    },
]

# Especificamos la configuración de la aplicación WSGI
WSGI_APPLICATION = 'backend.wsgi.application'

# Configuración de la base de datos, utilizando SQLite para desarrollo
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',  # Motor de base de datos SQLite
        'NAME': BASE_DIR / 'db.sqlite3',  # Nombre del archivo de base de datos
    }
}

# Validadores de contraseñas para la autenticación
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Configuración del idioma del proyecto
LANGUAGE_CODE = 'en-us'
# Configuración de la zona horaria
TIME_ZONE = 'America/Bogota'
# Habilitar la internacionalización
USE_I18N = True
# Habilitar el uso de zonas horarias
USE_TZ = True

# URL para servir archivos estáticos
STATIC_URL = 'static/'

# Especificar el tipo de campo auto incremental predeterminado para los modelos
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
# Importamos el módulo admin de django.contrib para la administración del sitio
from django.contrib import admin
# Importamos las funciones path e include desde django.urls para definir rutas
from django.urls import path, include

# Definimos las rutas principales del proyecto
urlpatterns = [
    # Ruta para acceder a la interfaz de administración de Django
    path('admin/', admin.site.urls),
    # Rutas relacionadas con la autenticación, incluyendo las definidas en authentication.urls
    path('api/auth/', include('authentication.urls')),
    # Rutas relacionadas con la gestión de pacientes, incluyendo las definidas en pacientes.urls
    path('api/pacientes/', include('pacientes.urls')),
    # Rutas relacionadas con la gestión de habitaciones, incluyendo las definidas en habitaciones.urls
    path('api/habitaciones/', include('habitaciones.urls')),
    # Rutas relacionadas con la gestión de servicios, incluyendo las definidas en servicios.urls
    path('api/servicios/', include('servicios.urls')),
    # Rutas relacionadas con la gestión de menús, incluyendo las definidas en menus.urls
    path('api/menus/', include('menus.urls')),
    # Rutas relacionadas con la gestión de pedidos, incluyendo las definidas en pedidos.urls
    path('api/pedidos/', include('pedidos.urls')),
]
# Importamos el módulo os para interactuar con variables de entorno del sistema operativo
import os

# Importamos la función get_wsgi_application de django.core.wsgi para configurar la aplicación WSGI
from django.core.wsgi import get_wsgi_application

# Establecemos la variable de entorno 'DJANGO_SETTINGS_MODULE' con el valor 'backend.settings'
# Esto indica a Django qué archivo de configuración debe usar
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')

# Llamamos a get_wsgi_application para obtener la aplicación WSGI que Django utilizará
application = get_wsgi_application()
# Importamos el módulo AppConfig de Django
from django.apps import AppConfig

# Definimos la configuración de la aplicación 'habitaciones'
class HabitacionesConfig(AppConfig):
    # Especificamos el tipo de campo por defecto para los modelos en esta aplicación
    default_auto_field = 'django.db.models.BigAutoField'
    # Especificamos el nombre de la aplicación
    name = 'habitaciones'
from django.db import models
from servicios.models import Servicio

class Habitacion(models.Model):
    nombre = models.CharField(max_length=255, unique=True)  # Cambiar de numero a nombre único
    servicio = models.ForeignKey(Servicio, on_delete=models.CASCADE)
    activo = models.BooleanField(default=True)

    def __str__(self):
        return self.nombre

class Cama(models.Model):
    nombre = models.CharField(max_length=50)
    habitacion = models.ForeignKey(Habitacion, related_name='camas', on_delete=models.CASCADE)
    activo = models.BooleanField(default=True)

    class Meta:
        unique_together = ('nombre', 'habitacion')  # El nombre de la cama debe ser único en la habitación

    def __str__(self):
        return f'{self.nombre} - {self.habitacion.nombre}'
from rest_framework import serializers
from .models import Habitacion, Cama
from servicios.models import Servicio

class CamaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Cama
        fields = ['id', 'nombre', 'activo']

class HabitacionSerializer(serializers.ModelSerializer):
    servicio_id = serializers.PrimaryKeyRelatedField(queryset=Servicio.objects.all(), source='servicio', write_only=True)
    servicio = serializers.ReadOnlyField(source='servicio.nombre')
    camas = CamaSerializer(many=True, read_only=True)

    class Meta:
        model = Habitacion
        fields = ['id', 'nombre', 'servicio_id', 'servicio', 'activo', 'camas']

    def create(self, validated_data):
        return Habitacion.objects.create(**validated_data)

    def update(self, instance, validated_data):
        instance.nombre = validated_data.get('nombre', instance.nombre)
        instance.servicio = validated_data.get('servicio', instance.servicio)
        instance.activo = validated_data.get('activo', instance.activo)
        instance.save()
        return instance
from django.urls import path
from .views import HabitacionListCreateView, HabitacionDetailView

urlpatterns = [
    path('', HabitacionListCreateView.as_view(), name='habitacion-list-create'),
    path('<int:pk>/', HabitacionDetailView.as_view(), name='habitacion-detail'),
]
from rest_framework import generics
from .models import Habitacion
from .serializers import HabitacionSerializer

class HabitacionListCreateView(generics.ListCreateAPIView):
    serializer_class = HabitacionSerializer

    def get_queryset(self):
        return Habitacion.objects.filter(activo=True)

class HabitacionDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Habitacion.objects.all()
    serializer_class = HabitacionSerializer
# Importamos el módulo AppConfig de Django
from django.apps import AppConfig

# Definimos la configuración de la aplicación 'menus'
class MenusConfig(AppConfig):
    # Especificamos el tipo de campo por defecto para los modelos en esta aplicación
    default_auto_field = 'django.db.models.BigAutoField'
    # Especificamos el nombre de la aplicación
    name = 'menus'
# Importamos el módulo de modelos de Django
from django.db import models

# Definimos un modelo para representar un menú
class Menu(models.Model):
    # El menú tiene un nombre, que es un campo de texto con un máximo de 255 caracteres
    nombre = models.CharField(max_length=255)

    # Representamos el menú como una cadena de texto
    def __str__(self):
        # Devolvemos el nombre del menú
        return self.nombre

# Definimos un modelo para representar una sección de un menú
class MenuSection(models.Model):
    # La sección pertenece a un menú, por lo que creamos una relación ForeignKey
    menu = models.ForeignKey(Menu, on_delete=models.CASCADE, related_name='sections')
    # La sección tiene un título, que es un campo de texto con un máximo de 255 caracteres
    titulo = models.CharField(max_length=255)

    # Representamos la sección como una cadena de texto
    def __str__(self):
        # Devolvemos el título de la sección
        return self.titulo

# Definimos un modelo para representar una opción de un menú
class MenuOption(models.Model):
    # La opción pertenece a una sección, por lo que creamos una relación ForeignKey
    section = models.ForeignKey(MenuSection, on_delete=models.CASCADE, related_name='options')
    # La opción tiene un texto, que es un campo de texto con un máximo de 255 caracteres
    texto = models.CharField(max_length=255)
    # La opción tiene un tipo, que es un campo de texto con un máximo de 50 caracteres
    # Este campo puede ser usado para categorizar la opción (por ejemplo, 'opciones', 'bebida', 'adicional', etc.)
    tipo = models.CharField(max_length=50)

    # Representamos la opción como una cadena de texto
    def __str__(self):
        # Devolvemos el texto de la opción
        return self.texto
# Importamos el módulo de serializers de Django REST framework
from rest_framework import serializers
# Importamos los modelos Menu, MenuSection y MenuOption desde el archivo models
from .models import Menu, MenuSection, MenuOption

# Definimos un serializer para representar el modelo MenuOption
class MenuOptionSerializer(serializers.ModelSerializer):
    # Meta clase que define el modelo y los campos a serializar
    class Meta:
        model = MenuOption  # Especificamos el modelo MenuOption
        fields = ['id', 'texto', 'tipo']  # Campos a incluir en la serialización

# Definimos un serializer para representar el modelo MenuSection
class MenuSectionSerializer(serializers.ModelSerializer):
    # Campos adicionales definidos como métodos personalizados
    adicionales = serializers.SerializerMethodField()
    platos_principales = serializers.SerializerMethodField()
    acompanantes = serializers.SerializerMethodField()
    bebidas = serializers.SerializerMethodField()

    # Meta clase que define el modelo y los campos a serializar
    class Meta:
        model = MenuSection  # Especificamos el modelo MenuSection
        fields = ['id', 'titulo', 'adicionales', 'platos_principales', 'acompanantes', 'bebidas']  # Campos a incluir en la serialización

    # Método para obtener las opciones del tipo 'adicionales'
    def get_adicionales(self, obj):
        # Filtramos las opciones por tipo y las serializamos
        return MenuOptionSerializer(obj.options.filter(tipo='adicionales'), many=True).data

    # Método para obtener las opciones del tipo 'platos_principales'
    def get_platos_principales(self, obj):
        # Filtramos las opciones por tipo y las serializamos
        return MenuOptionSerializer(obj.options.filter(tipo='platos_principales'), many=True).data

    # Método para obtener las opciones del tipo 'acompanantes'
    def get_acompanantes(self, obj):
        # Filtramos las opciones por tipo y las serializamos
        return MenuOptionSerializer(obj.options.filter(tipo='acompanantes'), many=True).data

    # Método para obtener las opciones del tipo 'bebidas'
    def get_bebidas(self, obj):
        # Filtramos las opciones por tipo y las serializamos
        return MenuOptionSerializer(obj.options.filter(tipo='bebidas'), many=True).data

# Definimos un serializer para representar el modelo Menu
class MenuSerializer(serializers.ModelSerializer):
    # Secciones del menú serializadas con un serializer anidado
    sections = MenuSectionSerializer(many=True, required=False)

    # Meta clase que define el modelo y los campos a serializar
    class Meta:
        model = Menu  # Especificamos el modelo Menu
        fields = ['id', 'nombre', 'sections']  # Campos a incluir en la serialización

    # Método para crear un nuevo menú junto con sus secciones y opciones
    def create(self, validated_data):
        # Obtenemos los datos de las secciones desde la solicitud
        sections_data = self.context['request'].data.get('sections', [])
        # Creamos el menú con los datos validados
        menu = Menu.objects.create(nombre=validated_data.get('nombre'))
        # Iteramos sobre cada sección para crearla junto con sus opciones
        for section_data in sections_data:
            # Extraemos las opciones de cada tipo
            adicionales_data = section_data.pop('adicionales', [])
            platos_principales_data = section_data.pop('platos_principales', [])
            acompanantes_data = section_data.pop('acompanantes', [])
            bebidas_data = section_data.pop('bebidas', [])
            # Creamos la sección correspondiente
            section = MenuSection.objects.create(menu=menu, titulo=section_data['titulo'])
            # Creamos las opciones asociadas a la sección
            for adicional_data in adicionales_data:
                MenuOption.objects.create(section=section, **adicional_data)
            for plato_principal_data in platos_principales_data:
                MenuOption.objects.create(section=section, **plato_principal_data)
            for acompanante_data in acompanantes_data:
                MenuOption.objects.create(section=section, **acompanante_data)
            for bebida_data in bebidas_data:
                MenuOption.objects.create(section=section, **bebida_data)
        # Retornamos el menú creado
        return menu

    # Método para actualizar un menú existente junto con sus secciones y opciones
    def update(self, instance, validated_data):
        # Obtenemos los datos de las secciones desde la solicitud
        sections_data = self.context['request'].data.get('sections', [])
        # Actualizamos el nombre del menú si se ha proporcionado un nuevo valor
        instance.nombre = validated_data.get('nombre', instance.nombre)
        instance.save()

        # Eliminamos secciones existentes que no están en la solicitud
        existing_section_ids = {section.id for section in instance.sections.all()}
        request_section_ids = {section_data.get('id') for section_data in sections_data if 'id' in section_data}
        sections_to_delete = existing_section_ids - request_section_ids
        if sections_to_delete:
            MenuSection.objects.filter(id__in=sections_to_delete).delete()

        # Iteramos sobre cada sección proporcionada en los datos
        for section_data in sections_data:
            # Extraemos las opciones de cada tipo
            adicionales_data = section_data.pop('adicionales', [])
            platos_principales_data = section_data.pop('platos_principales', [])
            acompanantes_data = section_data.pop('acompanantes', [])
            bebidas_data = section_data.pop('bebidas', [])
            section_id = section_data.get('id')

            # Si la sección ya existe, la actualizamos
            if section_id and MenuSection.objects.filter(id=section_id, menu=instance).exists():
                section = MenuSection.objects.get(id=section_id, menu=instance)
                section.titulo = section_data.get('titulo', section.titulo)
                section.save()

                # Eliminamos las opciones existentes para la sección
                section.options.all().delete()
            else:
                # Si la sección no existe, la creamos
                section = MenuSection.objects.create(menu=instance, **section_data)

            # Creamos las nuevas opciones para la sección
            for adicional_data in adicionales_data:
                MenuOption.objects.create(section=section, **adicional_data)
            for plato_principal_data in platos_principales_data:
                MenuOption.objects.create(section=section, **plato_principal_data)
            for acompanante_data in acompanantes_data:
                MenuOption.objects.create(section=section, **acompanante_data)
            for bebida_data in bebidas_data:
                MenuOption.objects.create(section=section, **bebida_data)

        # Retornamos la instancia del menú actualizada
        return instance
# Importamos la función path desde django.urls para definir rutas
from django.urls import path
# Importamos las vistas MenuListCreateView y MenuDetailView desde el archivo views
from .views import MenuListCreateView, MenuDetailView

# Definimos las rutas para la aplicación de menús
urlpatterns = [
    # Ruta para listar todos los menús y crear uno nuevo
    # Esta vista maneja solicitudes GET para listar y POST para crear
    path('', MenuListCreateView.as_view(), name='menu-list-create'),
    
    # Ruta para obtener, actualizar o eliminar un menú específico por su ID
    # Esta vista maneja solicitudes GET para obtener, PUT/PATCH para actualizar, y DELETE para eliminar
    path('<int:pk>/', MenuDetailView.as_view(), name='menu-detail'),
]
# Importamos el módulo generics de Django REST framework
from rest_framework import generics
# Importamos el modelo Menu desde el archivo models
from .models import Menu
# Importamos el serializer MenuSerializer desde el archivo serializers
from .serializers import MenuSerializer

# Definimos una vista genérica para listar y crear menús
class MenuListCreateView(generics.ListCreateAPIView):
    # Especificamos el queryset que será utilizado para recuperar todos los menús
    queryset = Menu.objects.all()
    # Especificamos el serializer que será utilizado para la serialización y deserialización de los datos
    serializer_class = MenuSerializer

# Definimos una vista genérica para recuperar, actualizar y eliminar un menú específico
class MenuDetailView(generics.RetrieveUpdateDestroyAPIView):
    # Especificamos el queryset que será utilizado para recuperar un menú específico
    queryset = Menu.objects.all()
    # Especificamos el serializer que será utilizado para la serialización y deserialización de los datos
    serializer_class = MenuSerializer
# Importamos el módulo AppConfig de Django
from django.apps import AppConfig

# Definimos la configuración de la aplicación 'pacientes'
class PacientesConfig(AppConfig):
    # Especificamos el tipo de campo por defecto para los modelos en esta aplicación
    default_auto_field = 'django.db.models.BigAutoField'
    # Especificamos el nombre de la aplicación
    name = 'pacientes'
from django.db import models
from django.core.exceptions import ValidationError
from habitaciones.models import Cama

class Paciente(models.Model):
    id = models.CharField(max_length=20, primary_key=True)  # Número de cédula
    name = models.CharField(max_length=100)
    cama = models.ForeignKey(Cama, on_delete=models.CASCADE)
    recommended_diet = models.CharField(max_length=255)
    activo = models.BooleanField(default=True)

    def save(self, *args, **kwargs):
        if Paciente.objects.filter(cama=self.cama, activo=True).exists():
            raise ValidationError('No se puede asignar más de un paciente activo a la misma cama.')
        super(Paciente, self).save(*args, **kwargs)

    def __str__(self):
        return self.name
from rest_framework import serializers
from .models import Paciente
from habitaciones.models import Cama

class CamaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Cama
        fields = ['id', 'nombre', 'habitacion']

class PacienteSerializer(serializers.ModelSerializer):
    cama_id = serializers.PrimaryKeyRelatedField(queryset=Cama.objects.all(), source='cama', write_only=True)
    cama = CamaSerializer(read_only=True)

    class Meta:
        model = Paciente
        fields = ['id', 'name', 'cama_id', 'cama', 'recommended_diet', 'activo']

    def create(self, validated_data):
        return Paciente.objects.create(**validated_data)

    def update(self, instance, validated_data):
        instance.name = validated_data.get('name', instance.name)
        instance.cama = validated_data.get('cama', instance.cama)
        instance.recommended_diet = validated_data.get('recommended_diet', instance.recommended_diet)
        instance.activo = validated_data.get('activo', instance.activo)
        instance.save()
        return instance
from django.urls import path
from .views import PacienteListCreateView, PacienteDetailView

urlpatterns = [
    path('', PacienteListCreateView.as_view(), name='paciente-list-create'),
    path('<int:pk>/', PacienteDetailView.as_view(), name='paciente-detail'),
]
from rest_framework import generics
from .models import Paciente
from .serializers import PacienteSerializer

class PacienteListCreateView(generics.ListCreateAPIView):
    serializer_class = PacienteSerializer

    def get_queryset(self):
        return Paciente.objects.filter(activo=True)

class PacienteDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Paciente.objects.all()
    serializer_class = PacienteSerializer
# Importamos el módulo AppConfig de Django
from django.apps import AppConfig

# Definimos la configuración de la aplicación 'pedidos'
class PedidosConfig(AppConfig):
    # Especificamos el tipo de campo por defecto para los modelos en esta aplicación
    default_auto_field = 'django.db.models.BigAutoField'
    # Especificamos el nombre de la aplicación
    name = 'pedidos'
from django.db import models
from pacientes.models import Paciente
from menus.models import Menu, MenuOption

class Pedido(models.Model):
    STATUS_CHOICES = [
        ('pendiente', 'Pendiente'),
        ('en_proceso', 'En Proceso'),
        ('completado', 'Completado'),
    ]

    paciente = models.ForeignKey(Paciente, on_delete=models.CASCADE)
    menu = models.ForeignKey(Menu, on_delete=models.CASCADE)
    opciones = models.ManyToManyField(MenuOption, through='PedidoMenuOption', blank=True, related_name='pedidos')
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pendiente')
    fecha_pedido = models.DateTimeField(auto_now_add=True)
    adicionales = models.JSONField(default=dict, blank=True)
    sectionStatus = models.JSONField(default=dict, blank=True)  # Campo para almacenar el estado de las secciones

    def __str__(self):
        return f"Pedido {self.id} - {self.paciente.name} - {self.status}"

class PedidoMenuOption(models.Model):
    pedido = models.ForeignKey(Pedido, on_delete=models.CASCADE)
    menu_option = models.ForeignKey(MenuOption, on_delete=models.CASCADE)
    selected = models.BooleanField(default=False)
from rest_framework import serializers
from pedidos.models import Pedido, PedidoMenuOption
from pacientes.models import Paciente
from pacientes.serializers import PacienteSerializer
from menus.models import Menu, MenuOption
from menus.serializers import MenuSerializer, MenuOptionSerializer

class PedidoSerializer(serializers.ModelSerializer):
    paciente = PacienteSerializer(read_only=True)
    menu = MenuSerializer(read_only=True)
    opciones = MenuOptionSerializer(source='pedidomenuoption_set', many=True, read_only=True)

    class Meta:
        model = Pedido
        fields = ['id', 'paciente', 'menu', 'opciones', 'status', 'fecha_pedido', 'adicionales', 'sectionStatus']

    def create(self, validated_data):
        opciones_data = self.initial_data.get('opciones', [])
        adicionales_data = validated_data.pop('adicionales')
        section_status_data = validated_data.pop('sectionStatus', {})
        paciente_id = self.initial_data.get('paciente')
        menu_id = self.initial_data.get('menu')

        paciente = Paciente.objects.get(id=paciente_id)
        menu = Menu.objects.get(id=menu_id)

        # Validamos que el paciente esté activo
        if not paciente.activo:
            raise serializers.ValidationError("El paciente seleccionado no está activo.")

        pedido = Pedido.objects.create(paciente=paciente, menu=menu, sectionStatus=section_status_data, **validated_data)

        for opcion_data in opciones_data:
            opcion_id = opcion_data.get('id')
            if opcion_id is not None:
                selected = opcion_data.get('selected', False)
                menu_option = MenuOption.objects.get(id=opcion_id)
                PedidoMenuOption.objects.create(pedido=pedido, menu_option=menu_option, selected=selected)

        pedido.adicionales = adicionales_data
        pedido.save()
        return pedido

    def update(self, instance, validated_data):
        opciones_data = self.initial_data.get('opciones', [])
        adicionales_data = validated_data.pop('adicionales', instance.adicionales)
        section_status_data = validated_data.pop('sectionStatus', instance.sectionStatus)

        instance.paciente = validated_data.get('paciente', instance.paciente)
        instance.menu = validated_data.get('menu', instance.menu)
        instance.status = validated_data.get('status', instance.status)
        instance.adicionales = adicionales_data
        instance.sectionStatus = section_status_data
        instance.save()

        if opciones_data:
            for opcion_data in opciones_data:
                opcion_id = opcion_data.get('id')
                if opcion_id is not None:
                    selected = opcion_data['selected']
                    menu_option = MenuOption.objects.get(id=opcion_id)
                    PedidoMenuOption.objects.update_or_create(
                        pedido=instance,
                        menu_option=menu_option,
                        defaults={'selected': selected}
                    )

        return instance
# Importamos la función path desde django.urls para definir rutas
from django.urls import path
# Importamos las vistas PedidoListCreateView, PedidoDetailView, PedidoStatusUpdateView y PedidoCompletadosView desde el archivo views
from .views import PedidoListCreateView, PedidoDetailView, PedidoStatusUpdateView, PedidoCompletadosView

# Definimos las rutas para la aplicación de pedidos
urlpatterns = [
    # Ruta para listar todos los pedidos y crear uno nuevo
    path('', PedidoListCreateView.as_view(), name='pedido-list-create'),
    
    # Ruta para obtener, actualizar o eliminar un pedido específico por su ID
    path('<int:pk>/', PedidoDetailView.as_view(), name='pedido-detail'),
    
    # Ruta para actualizar el estado de un pedido específico por su ID
    path('<int:pk>/status/', PedidoStatusUpdateView.as_view(), name='pedido-status-update'),

    # Ruta para obtener los pedidos completados y aplicar filtros
    path('completados/', PedidoCompletadosView.as_view(), name='pedido-completados'),
]
from rest_framework import generics, views
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Pedido
from .serializers import PedidoSerializer

class PedidoListCreateView(generics.ListCreateAPIView):
    queryset = Pedido.objects.all()
    serializer_class = PedidoSerializer

    @action(detail=False, methods=['get'])
    def pendientes(self, request):
        pedidos_pendientes = Pedido.objects.filter(status='pendiente')
        serializer = self.get_serializer(pedidos_pendientes, many=True)
        return Response(serializer.data)

class PedidoCompletadosView(views.APIView):
    def get(self, request):
        pedidos_completados = Pedido.objects.filter(status='completado')
        paciente_name = request.query_params.get('paciente', None)
        if paciente_name:
            pedidos_completados = pedidos_completados.filter(paciente__name__icontains=paciente_name)
        serializer = PedidoSerializer(pedidos_completados, many=True)
        return Response(serializer.data)

class PedidoDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Pedido.objects.all()
    serializer_class = PedidoSerializer

class PedidoStatusUpdateView(generics.UpdateAPIView):
    queryset = Pedido.objects.all()
    serializer_class = PedidoSerializer

    def partial_update(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=True)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)
        return Response(serializer.data)
# Importamos el módulo AppConfig de Django
from django.apps import AppConfig

# Definimos la configuración de la aplicación 'servicios'
class ServiciosConfig(AppConfig):
    # Especificamos el tipo de campo por defecto para los modelos en esta aplicación
    default_auto_field = 'django.db.models.BigAutoField'
    # Especificamos el nombre de la aplicación
    name = 'servicios'
from django.db import models

class Servicio(models.Model):
    nombre = models.CharField(max_length=255)
    activo = models.BooleanField(default=True)  # Nuevo campo para controlar el estado de habilitación

    def __str__(self):
        return self.nombre
from rest_framework import serializers
from .models import Servicio

class ServicioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Servicio
        fields = ['id', 'nombre', 'activo']  # Incluir el campo 'activo' en la serialización
from django.urls import path
from .views import ServicioListCreateView, ServicioDetailView

urlpatterns = [
    path('', ServicioListCreateView.as_view(), name='servicio-list-create'),
    path('<int:pk>/', ServicioDetailView.as_view(), name='servicio-detail'),
]
from rest_framework import generics
from .models import Servicio
from .serializers import ServicioSerializer

class ServicioListCreateView(generics.ListCreateAPIView):
    serializer_class = ServicioSerializer

    def get_queryset(self):
        # Filtramos solo los servicios que están activos
        return Servicio.objects.filter(activo=True)

class ServicioDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Servicio.objects.all()
    serializer_class = ServicioSerializer
# Clave secreta utilizada por Django para varias operaciones criptográficas
DJANGO_SECRET_KEY=ZOM50YBnVo12HpKqySoeXS9M621bNTB0JJ-mqFYpzUbnTFcMWfEh_7y2iB9ZUvVz6fg

# Modo de depuración. Si se establece en True, Django mostrará más información en caso de errores. Esto no debe ser usado en producción.
DJANGO_DEBUG=True

# Lista de hosts permitidos que pueden hacer solicitudes al servidor Django
DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
# Importamos el módulo os para interactuar con las variables de entorno del sistema operativo
import os
# Importamos el módulo sys para manipular el entorno de ejecución de Python
import sys

def main():
    """Run administrative tasks."""
    # Establecemos la variable de entorno 'DJANGO_SETTINGS_MODULE' con el valor 'backend.settings'
    # Esto indica a Django qué archivo de configuración debe usar
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
    
    try:
        # Intentamos importar la función execute_from_command_line desde django.core.management
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        # Si ocurre un error al importar Django, lanzamos un mensaje de error específico
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    
    # Ejecutamos la función execute_from_command_line, pasando los argumentos de la línea de comandos
    execute_from_command_line(sys.argv)

# Si el script se ejecuta directamente (no importado como módulo), llamamos a la función main()
if __name__ == '__main__':
    main()
